
#define MAXIMUMMORPHLENGTH 10
#define True 1
#define False 0

struct Sound {
  bit[NUMBEROFFEATURES] f;
}


struct Word {
  int l;
  Sound[l] s;
}

int word_length(Word w) { return w.l; }

bit sound_equal(Sound x, Sound y) {
  if (x == y) return 1;
  int f = 0;
  repeat (NUMBEROFFEATURES) {
      if (x.f[f] != y.f[f]) return 0;
      f++;
  }
  return 1;
}

bit word_equal(Word x, Word y) {
  if (x.l != y.l) return 0;
  for (int f = 0; f < x.l; f++) {
    if (!(sound_equal(x.s[f], y.s[f]))) return 0;
  }
  return 1;
}

Word concatenate3(Word a1,Word a2,Word a3) {
  Word a = new Word(l = a1.l + a2.l + a3.l, s = a1.s);
  a.s[a1.l :: a2.l] = a2.s;
  a.s[(a2.l + a1.l) :: a3.l] = a3.s;
  return a;
}

Word concatenate(Word a1,Word a2) {
  Word a = new Word(l = a1.l + a2.l,s = a1.s);
  a.s[a1.l :: a2.l] = a2.s;
  return a;
}

Word remove_sound(Word w,int j) {
  Word x = new Word(l = w.l - 1);
  //		    s = w.s[0::j]);
  for (int k = 0; k < j; k++)
    x.s[k] = w.s[k];
  for (int k = j + 1; k < w.l; k++)
    x.s[k-1] = w.s[k];
  //  x.s[j::(x.l - j)] = w.s[(j + 1)::(w.l - j - 1)];
  return x;
}


Word make_word([int l],Sound[l] s) {
  Word w = new Word(l = l);
  w.s = s;
  return w;  
}

generator Word unknown_word() {
  int l = ??;
  assert l >= 0;
  
  Word w = new Word(l = l);
  int j = 0;
  repeat(MAXIMUMMORPHLENGTH) {
    if (j < l)
      w.s[j] = UNKNOWNSOUND;
    j++;
  }
  return w;
}

struct Predicate{}
struct EndOfString extends Predicate{}
struct Specification extends Predicate{
  bit[NUMBEROFFEATURES] mask;
  bit[NUMBEROFFEATURES] preference;
}
struct ConstantPhoneme extends Predicate{
  Sound phoneme;
}

generator Sound unknown_sound() { return UNKNOWNSOUND; }
  
generator Predicate unknown_predicate() {
  return ?? ? new Specification(mask = ??, preference = ??) :
    (?? ? new EndOfString() : new ConstantPhoneme(phoneme = UNKNOWNSOUND));
}

#define UNKNOWNPREDICATE (?? ? new Specification(mask = ??, preference = ??) : (?? ? new EndOfString() : new ConstantPhoneme(phoneme = UNKNOWNSOUND)))

generator Specification unknown_specification() {
  return new Specification(mask = ??,
			   preference = ??);
}

bit matches_specification(Sound sound, Specification specification) {
  bit[NUMBEROFFEATURES] mistakeVector = (sound.f^(specification.preference))&specification.mask;
  int f = 0;
  repeat (NUMBEROFFEATURES) {
    if (mistakeVector[f]) return 0;
    f++;
  }
  return 1;
}

bit matches_predicate(Predicate p, Word u, int j) {
  bit match;
  switch (p) {
  case EndOfString: { match = (j == -1 || j == u.l); }
  case ConstantPhoneme: {
    if (j < 0 || j >= u.l) match = 0;
    else match = sound_equal(u.s[j], p.phoneme);
  }
  case Specification: {
      if (empty_specification(p)) match = 1;
      else if (j < 0 || j >= u.l) match = 0;
      else match = matches_specification(u.s[j], p);
    }
  }
  return match;
}

Sound apply_specification(Specification specification, Sound sound) {
  return new Sound(f = 
		   // New positives induced by the specification
		   (specification.mask & specification.preference) |
		   // Old features minus the ones that were removed by the specification
		   ((~specification.mask) & sound.f));
}

int predicate_cost(Predicate s) {
  switch(s) {
  case EndOfString:{ return 1; }
  case ConstantPhoneme:{ return 0; }
  case Specification:{
    if (empty_specification(s)) return 0;
    int c = 3;
    for (int f = 0; f < NUMBEROFFEATURES; f++) {
      if (s.mask[f])
	c += s.preference[f] ? 1 : 2;
    }
    return c;
  }
  }
}

bit empty_specification(Specification s) {
  int f = 0;
  repeat(NUMBEROFFEATURES) {
    if (s.mask[f]) return 0;
    f++;
  }
  return 1;
}
  
struct Rule {
  Specification focus;
  Specification structural_change;
  Predicate left_trigger;
  Predicate right_trigger;
}

generator Rule unknown_rule() {
  return new Rule(focus = new Specification(mask = ??, preference = ??),
		  structural_change = new Specification(mask = ??, preference = ??),
		  left_trigger = UNKNOWNPREDICATE,
		  right_trigger = UNKNOWNPREDICATE);
}

int alternation_cost(Rule r) {
  return predicate_cost(r.right_trigger) + predicate_cost(r.left_trigger);
}

int rule_cost(Rule r) {
  return predicate_cost(r.right_trigger) + predicate_cost(r.left_trigger) +
    predicate_cost(r.focus) + predicate_cost(r.structural_change);
}


Word apply_rule(Rule r, Word u) {
  Specification focus = r.focus;
  Specification structural_change = r.structural_change;
  Predicate left_trigger = r.left_trigger;
  Predicate right_trigger = r.right_trigger;

  Word output = new Word(l = u.l);
  
  assert !empty_specification(focus);

  for (int j = 0; j < u.l; j++) {
    bit left_okay = matches_predicate(left_trigger, u, j - 1);    
    bit middle_okay = matches_specification(u.s[j], focus);
    bit right_okay = matches_predicate(right_trigger, u, j + 1);
    bit everything_okay = left_okay && middle_okay && right_okay;

    output.s[j] = everything_okay ?
      apply_specification(structural_change, u.s[j]) :
      u.s[j];
  }
  
  return output;
}
