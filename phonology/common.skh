// alternations basically already have their specifications given
// so it should be okay that they are a little bit bigger
#ifndef ALTERNATIONPROBLEM
#define MAXIMUMCOST 11
#else
#define MAXIMUMCOST 14
#endif
int validateCost(int c) { assert c < MAXIMUMCOST; return c; }

#define True 1
#define False 0

struct Sound {
  bit[NUMBEROFFEATURES] f;
}


struct Word {
  int l;
  Sound[l] s;
}

int word_length(Word w) { return w.l; }

bit sound_equal(Sound x, Sound y) {
  /* if (x == y) return 1; */
  /* int f = 0; */
  /* repeat (NUMBEROFFEATURES) { */
  /*     if (x.f[f] != y.f[f]) return 0; */
  /*     f++; */
  /* } */
  /* return 1; */
  return x == y;
}

bit word_equal(Word x, Word y) {
  if (x.l != y.l) return 0;
  for (int f = 0; f < x.l; f++) {
    if (!(sound_equal(x.s[f], y.s[f]))) return 0;
  }
  return 1;
}

Word concatenate3(Word a1,Word a2,Word a3) {
  if (a1.l == 0 && a3.l == 0) return a2;
  if (a1.l == 0) return concatenate(a2,a3);
  if (a3.l == 0) return concatenate(a1,a2);
  Word a = new Word(l = a1.l + a2.l + a3.l, s = a1.s);
  a.s[a1.l :: a2.l] = a2.s;
  a.s[(a2.l + a1.l) :: a3.l] = a3.s;
  return a;
}

Word concatenate(Word a1,Word a2) {
  Word a = new Word(l = a1.l + a2.l,s = a1.s);
  a.s[a1.l :: a2.l] = a2.s;
  return a;
}

Word remove_sound(Word w,int j) {
  Word x = new Word(l = w.l - 1);
  for (int k = 0; k < j; k++)
    x.s[k] = w.s[k];
  for (int k = j + 1; k < w.l; k++)
    x.s[k-1] = w.s[k];
  return x;
}

Word make_word([int l],Sound[l] s) {
  Word w = new Word(l = l);
  for (int j = 0; j < l; j++) {
    if (j < l) w.s[j] = s[j];
  }  
  return w;  
}

generator Word unknown_word() {
  int l = ??;
  assert l >= 0 && l <= MAXIMUMMORPHLENGTH;
  
  Word w = new Word(l = l);
  int j = 0;
  repeat(MAXIMUMMORPHLENGTH) {
    if (j < l)
      w.s[j] = UNKNOWNSOUND;
    j++;
  }
  return w;
}

struct Specification{}
struct Vector extends Specification{
  bit[NUMBEROFFEATURES] mask;
  bit[NUMBEROFFEATURES] preference;
}
struct ConstantPhoneme extends Specification{
  Sound phoneme;
}

bit specification_equal(Specification p, Specification q) {
  if (p == null || q == null) return p == null && q == null;
  switch (p) {
  case Vector:{
    switch (q) {
    case Vector:{
      return p.mask == q.mask && (p.preference&p.mask) == (q.preference&q.mask);
    }
    case ConstantPhoneme:{ return 0; }
    }
  }
  case ConstantPhoneme:{
    switch (q) {
    case Vector:{ return 0; }
    case ConstantPhoneme:{ return p.phoneme == q.phoneme; }
    }
  }
  }
}

bit empty_specification(Specification p) {
  if (p == null) return 0;
  switch (p) {
  case Vector:{
    return empty_vector(p.mask);
  }
  case ConstantPhoneme:{ return 0; }
  }
}

bit constant_specification(Specification p) {
  if (p == null) return 0;
  switch (p) {
  case Vector:{return 0;
  }
  case ConstantPhoneme:{ return 1; }
  }
}

Sound extract_constant_sound(Specification p) {
  if (p == null) return null;
  switch (p) {
  case Vector:{return null;}
  case ConstantPhoneme:{ return p.phoneme; }
  }
}

bit matches_specification(Sound sound, Specification specification) {
  switch (specification) {
  case Vector:{
    bit[NUMBEROFFEATURES] mistakeVector = (sound.f^(specification.preference))&specification.mask;
    int f = 0;
    repeat (NUMBEROFFEATURES) {
      if (mistakeVector[f]) return 0;
      f++;
    }
    return 1;
  }
  case ConstantPhoneme: {
    return sound_equal(sound, specification.phoneme);
  }
  }
}

Sound apply_specification(Specification specification, Sound sound) {
  switch (specification) {
  case Vector:{
    return features2sound(
		     // New positives induced by the specification
		     (specification.mask & specification.preference) |
		     // Old features minus the ones that were removed by the specification
		     ((~specification.mask) & sound.f));
  }
  case ConstantPhoneme:{
    return specification.phoneme;
  }
  }
}

bit empty_vector(bit[NUMBEROFFEATURES] v) {
  int j = 0;
  repeat (NUMBEROFFEATURES){
    if (v[j]) return 0;
    j++;
  }
  return 1;
}

#ifdef SYLLABLEBOUNDARYFEATURE
int syllable_starting_at(Word u, int e) {
  // returns -1 if there is no syllable starting at e
  // returns the index of the end of the syllable otherwise
  if (e == 0 || u[e] == SYLLABLEBOUNDARYPHONEME) {
    for (int d = 1; d < 4; d++) {
      int test_index = e + d;
      if (test_index == u.l) return u.l - 1;
      if (u[test_index] == SYLLABLEBOUNDARYPHONEME)
	return test_index - 1;
    }
  }
  return -1;
}
int syllable_ending_at(Word u, int e) {
  // returns -1 if there is no syllable ending at e
  // returns the index of the start of the syllable otherwise
  if (e == u.l || u[e] == SYLLABLEBOUNDARYPHONEME) {
    for (int d = 1; d < 4; d++) {
      int test_index = e - d;
      if (test_index == 0) return 0;
      if (u[test_index] == SYLLABLEBOUNDARYPHONEME)
	return test_index + 1;
    }
  }
  return -1;
}
int is_syllable_specification(Specification s) {
  if (s == null) { return 0; }
  switch(s){
  case Vector:{ return 0; }
  case ConstantPhoneme:{ return s.phoneme == SYLLABLEBOUNDARYPHONEME;}
  }
}
int has_syllable_feature(Specification s) {
  if (s == null) { return 0; }
  switch(s){
  case Vector:{
    return s.mask[SYLLABLEBOUNDARYFEATURE];
  }
  case ConstantPhoneme:{ return 0;}
  }
}
#endif

int specification_cost(Specification s) {
  if (s == null) return 2;
  switch(s) {
  case ConstantPhoneme:{ return 2; }
  case Vector:{
    int c = 1;
    int f = 0;
    repeat (NUMBEROFFEATURES) {
      c = validateCost(c + s.mask[f]);
      f++;
    }
    // Alternation problems basically have their specification already given
    // So don't limit it
#ifndef ALTERNATIONPROBLEM    
    assert c < 5; // at most 3 features mentioned
#endif
    return c;
  }
  }
}


int guard_specification_cost(Specification s) {
  if (s == null) return 0;
  switch(s) {
  case ConstantPhoneme:{ return 2; }
  case Vector:{
    //    if (empty_vector(s.mask)) return 1;
    //    assert !empty_vector(s.mask);
    int c = 1;
    int f = 0;
    repeat (NUMBEROFFEATURES) {
      c = validateCost(c + s.mask[f]);
      f++;
    }
    assert c < 5; // at most 3 features mentioned
    return c;
  }
  }
}

struct Guard {
  bit endOfString; // is it constrains to be at the end of string?
  bit starred; // is it of the form spec*spec2
  Specification spec; // Primary specification - holds immediately adjacent
  Specification spec2; // Secondary specification - holds one apart from adjacent
}

bit guard_equal(Guard p, Guard q) {
  return p.endOfString == q.endOfString &&
    p.starred == q.starred &&
    specification_equal(p.spec, q.spec) &&
    specification_equal(p.spec2, q.spec2);
}

struct Rule {
  Specification focus;
  Specification structural_change;
  Guard left_trigger;
  Guard right_trigger;
  // If we are inserting a new phoneme, copy it from this offset:
  // 0 = do not copy; -(1|2) = copy from left; +(1|2) = copy from right
  int copyOffset;
}


/* it's possible for structural changes to be redundant or make no sense
for example : [+hi  +low] or [-middle] 
this forces them into a canonical form. */

#define MUTUALLYEXCLUDE_(f1,f2,f3)\
      assert s.preference[f1];\
      assert !s.mask[f2];\
      assert !s.mask[f3];\
      s.mask[f2] = 1;\
      s.mask[f3] = 1;\
      s.preference[f2] = 0;\
      s.preference[f3] = 0;

#define MUTUALLYEXCLUDE(f1,f2,f3)\
  if (s.mask[f1]) {\
MUTUALLYEXCLUDE_(f1,f2,f3)\
  }else if(s.mask[f2]){	  \
    MUTUALLYEXCLUDE_(f2,f1,f3)\
      }else if(s.mask[f3]){\
    MUTUALLYEXCLUDE_(f3,f1,f2)\
      }

bit fix_structural_change(Rule r) {
  Specification s = r.structural_change;
  if (s == null) return 1;
  switch (s){
  case ConstantPhoneme:{}
  case Vector:{
    MUTUALLYEXCLUDE(HIGHFEATURE,MIDDLEFEATURE,LOWFEATURE)
      ;
    MUTUALLYEXCLUDE(FRONTFEATURE,CENTRALFEATURE,BACKFEATURE)
      ;
      }
  }
  return 1;
}

bit is_deletion_rule(Rule r) { return r.structural_change == null; }
bit is_insertion_rule(Rule r) { return r.focus == null; }

bit rule_equal(Rule p, Rule q) {
  return specification_equal(p.focus, q.focus) &&
    specification_equal(p.structural_change, q.structural_change) &&
    guard_equal(p.left_trigger, q.left_trigger) &&
    guard_equal(p.right_trigger, q.right_trigger) &&
    p.copyOffset == q.copyOffset;
}

bit alternation_equal(Rule p, Rule q) {
  return guard_equal(p.left_trigger, q.left_trigger) &&
    guard_equal(p.right_trigger, q.right_trigger);
}

generator Guard unknown_guard() {
  Specification s = unknown_specification();
  Specification s2 = unknown_specification();
  return new Guard(endOfString = ??, starred = ??, spec = {| null | s |}, spec2 = {| null | s2 |});
}
generator Specification unknown_specification() {
  return {| new Vector(mask = ??, preference = ??) | new ConstantPhoneme(phoneme = UNKNOWNSOUND) |};
}
  
generator Rule unknown_rule() {
  return new Rule(focus = {| null | unknown_specification() |},
		  structural_change = {| null | unknown_specification() |},
		  left_trigger = unknown_guard(),
		  right_trigger = unknown_guard(),
		  copyOffset = {| 0 | 1 | -1 | -2 | 2 |});
}

int alternation_cost(Rule r) {
  // For alternations the focus and structural change don't matter because they are essentially given by the problem
  return guard_cost(r.right_trigger) + guard_cost(r.left_trigger);
}

int guard_cost(Guard g) {
  return validateCost(guard_specification_cost(g.spec) +
		      guard_specification_cost(g.spec2) +
		      g.endOfString +
		      g.starred);
}

// apply_guard(u, g, 0)[j] = .*g matches u[0],u[1],...,u[j-1]. eg, the first j elements of u.
// apply_guard(u, g, 1)[j] = g.* matches u[j],u[j+1],...,u[l-1], eg, from j onward
bit[l+1] apply_guard([int l], Sound[l] u, Guard g, bit R){
  // guard sanity checks
  if (g.spec == null) assert g.spec2 == null;
  if (g.starred) { // * applies to the second specification
    assert g.spec != null && g.spec2 != null;
    // do not put a star on constant
    assert !constant_specification(g.spec);
  }


  // The index counts how many sounds we have consumed from the input
  // consider making these macros if it ends up being too slow
  // not sure if that even matters
/* #define index2okay(i) (R? (l - (i)) : i) */
/* #define index2sound(o) (R? (l - 1 - o) : o) */
  int index2okay(int i){
    if (R) return l - i;
    else return i;
  }
  int index2sound(int o){
    if (R) return l - 1 - (o - 1);
    else return (o - 1);
  }

  bit[l + 1] okay;
  // the only way that the empty string can be matched by .*g is if g is either empty or #
  // # by itself entails that both of the specifications are null
  okay[index2okay(0)] = (g.spec == null && g.spec2 == null);

  // State machine for starred: either in accepting or rejecting state
  bit accepting = 0;
  for (int j = 1; j <= l; j++) {
    // j counts how many sounds we have consumed from the input
    Sound this_sound = u[index2sound(j)]; // R sounds: (l-1), (l-2), ..., 0
    bit this_is_okay = 1;
    if (g.starred) { // (#?)gg*
      bit stay_in_accepting_state = accepting && matches_specification(this_sound, g.spec);
      if (!g.endOfString) { // gg*_
	accepting = matches_specification(this_sound, g.spec2) || stay_in_accepting_state;
      } else { // #gg*_
	accepting = matches_specification(u[index2sound(1)], g.spec2) &&
	  (j == 1 || stay_in_accepting_state);
      }
      this_is_okay = accepting;
    } else if (g.endOfString && g.spec == null) { // #_
      this_is_okay = 0;
    } else { // #?g?g?
      this_is_okay = this_is_okay && (g.spec == null || matches_specification(this_sound, g.spec));
      // This is the index of whatever we were looking at in the previous loop iteration
      int secondary_index = index2sound(j - 1); //R? (l + 1 - j):(j - 2);
      this_is_okay = this_is_okay && (g.spec2 == null ||
				      (j > 1 && matches_specification(u[secondary_index], g.spec2)));
      if (g.endOfString) { // is this off by one???
	// #g _
	if (g.spec2 == null) this_is_okay = this_is_okay && j == 1;
	// #gg _
	else                 this_is_okay = this_is_okay && j == 2;
      }
    }

    okay[index2okay(j)] = this_is_okay;
  }

  return okay;
}

int rule_cost(Rule r) {
  return validateCost(guard_cost(r.right_trigger) + guard_cost(r.left_trigger) +
		      specification_cost(r.focus) + specification_cost(r.structural_change));
}

Word apply_rule(Rule r, Word u) {
  Specification focus = r.focus;
  Specification structural_change = r.structural_change;
  Guard left_trigger = r.left_trigger;
  Guard right_trigger = r.right_trigger;

  // sanity check
  if (focus != null) assert r.copyOffset == 0; // not inserting so don't copy
  if (r.copyOffset != 0) assert empty_specification(structural_change);
  // K > [features] is always equivalent to K > K at a cost which is no greater
  if (constant_specification(focus)) assert constant_specification(structural_change) || structural_change == null;
#ifdef SYLLABLEBOUNDARYFEATURE
  // Syllables are encoded only as the special syllable phoneme
  assert !has_syllable_feature(left_trigger.spec);
  assert !has_syllable_feature(left_trigger.spec2);
  assert !has_syllable_feature(right_trigger.spec);
  assert !has_syllable_feature(right_trigger.spec2);
  assert !has_syllable_feature(focus);
  assert !has_syllable_feature(structural_change);
#endif
#ifndef SYLLABLEBOUNDARYFEATURE
  assert r.copyOffset == 0;
#endif
  
  Sound[u.l + 1] output;

  bit[u.l + 1] right_okay = apply_guard(u.s,right_trigger,1);
  bit right_final_okay = right_okay[0];
  
  bit[u.l + 1] left_okay = apply_guard(u.s,left_trigger,0);
  bit left_final_okay = left_okay[u.l];


  bit[u.l] middle_okay;
  for (int j = 0; j < u.l; j++) {
    middle_okay[j] = focus == null || matches_specification(u.s[j], focus);
  }

  bit[u.l] triggered;
  for (int j = 0; j < u.l; j++)
    triggered[j] = middle_okay[j] && right_okay[j + 1] && left_okay[j];

  int output_length; // how long is the output
  // Deletion rule
  if (structural_change == null) {
    assert focus != null;

    // special case: rule doesn't apply
    bit ruleApplies = 0;
    for (int j = 0; j < u.l; j++){
      if (triggered[j]) {
	assert !ruleApplies;
	ruleApplies = 1;
      }
    }
    if (!ruleApplies) return u;
    
    int outputIndex = 0;
    for (int j = 0; j < u.l; j++) {
      if (!triggered[j]) {
	output[outputIndex] = u.s[j];
	outputIndex++;
      }
    }
    output_length = u.l - 1;
  } else if (focus == null) { // insertion rule
    if (r.copyOffset == 0) // not copying
      assert constant_specification(structural_change);
    else // copying
      assert empty_specification(structural_change);

    bit inserted = 0;
    // Should we insert before u[j]?
    for (int j = 0; j <= u.l; j++) {
      if (left_okay[j] && right_okay[j]) {
	assert !inserted;
	inserted = 1;
	output[j] = extract_constant_sound(structural_change);
      }
      if (j < u.l) 
	output[j + inserted] = u.s[j];
    }
    if (!inserted) return u;
    output_length = u.l + inserted;
  } else { // Modification rule
    for (int j = 0; j < u.l; j++) {
      output[j] = triggered[j] ?
	apply_specification(structural_change, u.s[j]) :
	u.s[j];
    }
    output_length = u.l;
  }
  
  return new Word(s = output[0::output_length], l = output_length);
}
