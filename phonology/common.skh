
#define MAXIMUMCOST 20
int validateCost(int c) { assert c < MAXIMUMCOST; return c; }

#define True 1
#define False 0

struct Sound {
  bit[NUMBEROFFEATURES] f;
}


struct Word {
  int l;
  Sound[l] s;
}

int word_length(Word w) { return w.l; }

bit sound_equal(Sound x, Sound y) {
  if (x == y) return 1;
  int f = 0;
  repeat (NUMBEROFFEATURES) {
      if (x.f[f] != y.f[f]) return 0;
      f++;
  }
  return 1;
}

bit word_equal(Word x, Word y) {
  if (x.l != y.l) return 0;
  for (int f = 0; f < x.l; f++) {
    if (!(sound_equal(x.s[f], y.s[f]))) return 0;
  }
  return 1;
}

Word concatenate3(Word a1,Word a2,Word a3) {
  if (a1.l == 0 && a3.l == 0) return a2;
  if (a1.l == 0) return concatenate(a2,a3);
  if (a3.l == 0) return concatenate(a1,a2);
  Word a = new Word(l = a1.l + a2.l + a3.l, s = a1.s);
  a.s[a1.l :: a2.l] = a2.s;
  a.s[(a2.l + a1.l) :: a3.l] = a3.s;
  return a;
}

Word concatenate(Word a1,Word a2) {
  Word a = new Word(l = a1.l + a2.l,s = a1.s);
  a.s[a1.l :: a2.l] = a2.s;
  return a;
}

Word remove_sound(Word w,int j) {
  Word x = new Word(l = w.l - 1);
  for (int k = 0; k < j; k++)
    x.s[k] = w.s[k];
  for (int k = j + 1; k < w.l; k++)
    x.s[k-1] = w.s[k];
  return x;
}

Word make_word([int l],Sound[l] s) {
  Word w = new Word(l = l);
  for (int j = 0; j < l; j++) {
    if (j < l) w.s[j] = s[j];
  }  
  return w;  
}

generator Word unknown_word() {
  int l = ??;
  assert l >= 0 && l <= MAXIMUMMORPHLENGTH;
  
  Word w = new Word(l = l);
  int j = 0;
  repeat(MAXIMUMMORPHLENGTH) {
    if (j < l)
      w.s[j] = UNKNOWNSOUND;
    j++;
  }
  return w;
}

struct Specification{}
struct Vector extends Specification{
  bit[NUMBEROFFEATURES] mask;
  bit[NUMBEROFFEATURES] preference;
}
struct ConstantPhoneme extends Specification{
  Sound phoneme;
}

bit specification_equal(Specification p, Specification q) {
  if (p == null || q == null) return p == null && q == null;
  switch (p) {
  case Vector:{
    switch (q) {
    case Vector:{
      return p.mask == q.mask && (p.preference&p.mask) == (q.preference&q.mask);
    }
    case ConstantPhoneme:{ return 0; }
    }
  }
  case ConstantPhoneme:{
    switch (q) {
    case Vector:{ return 0; }
    case ConstantPhoneme:{ return p.phoneme == q.phoneme; }
    }
  }
  }
}

bit empty_specification(Specification p) {
  if (p == null) return 0;
  switch (p) {
  case Vector:{
    return empty_vector(p.mask);
  }
  case ConstantPhoneme:{ return 0; }
  }
}

bit constant_specification(Specification p) {
  if (p == null) return 0;
  switch (p) {
  case Vector:{return 0;
  }
  case ConstantPhoneme:{ return 1; }
  }
}

Sound extract_constant_sound(Specification p) {
  if (p == null) return null;
  switch (p) {
  case Vector:{return null;}
  case ConstantPhoneme:{ return p.phoneme; }
  }
}

bit matches_specification(Sound sound, Specification specification) {
  switch (specification) {
  case Vector:{
    bit[NUMBEROFFEATURES] mistakeVector = (sound.f^(specification.preference))&specification.mask;
    int f = 0;
    repeat (NUMBEROFFEATURES) {
      if (mistakeVector[f]) return 0;
      f++;
    }
    return 1;
  }
  case ConstantPhoneme: {
    return sound_equal(sound, specification.phoneme);
  }
  }
}

Sound apply_specification(Specification specification, Sound sound) {
  switch (specification) {
  case Vector:{
    return new Sound(f = 
		     // New positives induced by the specification
		     (specification.mask & specification.preference) |
		     // Old features minus the ones that were removed by the specification
		     ((~specification.mask) & sound.f));
  }
  case ConstantPhoneme:{
    return specification.phoneme;
  }
  }
}

bit empty_vector(bit[NUMBEROFFEATURES] v) {
  int j = 0;
  repeat (NUMBEROFFEATURES){
    if (v[j]) return 0;
    j++;
  }
  return 1;
}

bit consonant_specification(Specification s) {
  if (s == null) return 0;
  switch(s) {
  case Vector:{return 0;}
  case ConstantPhoneme:{return 1;}
  }
}

int specification_cost(Specification s) {
  if (s == null) return 2;
  switch(s) {
  case ConstantPhoneme:{ return 2; }
  case Vector:{
    int c = 1;
    int f = 0;
    repeat (NUMBEROFFEATURES) {
      c = validateCost(c + s.mask[f]);
      f++;
    }
    // Alternation problems basically have their specification already given
    // So don't limit it
#ifndef ALTERNATIONPROBLEM    
    assert c < 5; // at most 3 features mentioned
#endif
    return c;
  }
  }
}


int guard_specification_cost(Specification s) {
  if (s == null) return 0;
  switch(s) {
  case ConstantPhoneme:{ return 2; }
  case Vector:{
    //    if (empty_vector(s.mask)) return 1;
    //    assert !empty_vector(s.mask);
    int c = 1;
    int f = 0;
    repeat (NUMBEROFFEATURES) {
      c = validateCost(c + s.mask[f]);
      f++;
    }
    assert c < 5; // at most 3 features mentioned
    return c;
  }
  }
}

struct Guard {
  bit endOfString; // is it constrains to be at the end of string?
  bit starred; // is it of the form spec*spec2
  Specification spec; // Primary specification - holds immediately adjacent
  Specification spec2; // Secondary specification - holds one apart from adjacent
}

bit guard_equal(Guard p, Guard q) {
  return p.endOfString == q.endOfString &&
    p.starred == q.starred &&
    specification_equal(p.spec, q.spec) &&
    specification_equal(p.spec2, q.spec2);
}

struct Rule {
  Specification focus;
  Specification structural_change;
  Guard left_trigger;
  Guard right_trigger;
  // If we are inserting a new phoneme, copy it from this offset:
  // 0 = do not copy; -(1|2) = copy from left; +(1|2) = copy from right
  int copyOffset;
}


/* it's possible for structural changes to be redundant or make no sense
for example : [+hi  +low] or [-middle] 
this forces them into a canonical form. */

#define MUTUALLYEXCLUDE_(f1,f2,f3)\
      assert s.preference[f1];\
      assert !s.mask[f2];\
      assert !s.mask[f3];\
      s.mask[f2] = 1;\
      s.mask[f3] = 1;\
      s.preference[f2] = 0;\
      s.preference[f3] = 0;

#define MUTUALLYEXCLUDE(f1,f2,f3)\
  if (s.mask[f1]) {\
MUTUALLYEXCLUDE_(f1,f2,f3)\
  }else if(s.mask[f2]){	  \
    MUTUALLYEXCLUDE_(f2,f1,f3)\
      }else if(s.mask[f3]){\
    MUTUALLYEXCLUDE_(f3,f1,f2)\
      }

bit fix_structural_change(Rule r) {
  Specification s = r.structural_change;
  if (s == null) return 1;
  switch (s){
  case ConstantPhoneme:{}
  case Vector:{
    MUTUALLYEXCLUDE(HIGHFEATURE,MIDDLEFEATURE,LOWFEATURE)
      ;
    MUTUALLYEXCLUDE(FRONTFEATURE,CENTRALFEATURE,BACKFEATURE)
      ;
      }
  }
  return 1;
}

bit is_deletion_rule(Rule r) { return r.structural_change == null; }
bit is_insertion_rule(Rule r) { return r.focus == null; }

bit rule_equal(Rule p, Rule q) {
  return specification_equal(p.focus, q.focus) &&
    specification_equal(p.structural_change, q.structural_change) &&
    guard_equal(p.left_trigger, q.left_trigger) &&
    guard_equal(p.right_trigger, q.right_trigger) &&
    p.copyOffset == q.copyOffset;
}

bit alternation_equal(Rule p, Rule q) {
  return guard_equal(p.left_trigger, q.left_trigger) &&
    guard_equal(p.right_trigger, q.right_trigger);
}

generator Guard unknown_guard() {
  Specification s = unknown_specification();
  Specification s2 = unknown_specification();
  return new Guard(endOfString = ??, starred = ??, spec = {| null | s |}, spec2 = {| null | s2 |});
}
generator Specification unknown_specification() {
  return {| new Vector(mask = ??, preference = ??) | new ConstantPhoneme(phoneme = UNKNOWNSOUND) |};
}
  
generator Rule unknown_rule() {
  return new Rule(focus = {| null | unknown_specification() |},
		  structural_change = {| null | unknown_specification() |},
		  left_trigger = unknown_guard(),
		  right_trigger = unknown_guard(),
		  copyOffset = {| 0 | 1 | -1 | -2 | +2 |});
}

int alternation_cost(Rule r) {
  // For alternations the focus and structural change don't matter because they are essentially given by the problem
  return guard_cost(r.right_trigger) + guard_cost(r.left_trigger);
}

int guard_cost(Guard g) {
  return validateCost(guard_specification_cost(g.spec) +
		      guard_specification_cost(g.spec2) +
		      g.endOfString +
		      g.starred);
}

int rule_cost(Rule r) {
  return validateCost(guard_cost(r.right_trigger) + guard_cost(r.left_trigger) +
		      specification_cost(r.focus) + specification_cost(r.structural_change));
}

Word apply_rule(Rule r, Word u) {
  Specification focus = r.focus;
  Specification structural_change = r.structural_change;
  Guard left_trigger = r.left_trigger;
  Guard right_trigger = r.right_trigger;

  // sanity check
  if (left_trigger.spec == null) assert left_trigger.spec2 == null;
  if (right_trigger.spec == null) assert right_trigger.spec2 == null;
  if (focus != null) assert r.copyOffset == 0; // not inserting so don't copy
  if (r.copyOffset != 0) assert empty_specification(structural_change);
  
  Sound[u.l + 1] output;

  // * applies to the second spec
  if (left_trigger.starred)
    assert left_trigger.spec != null && left_trigger.spec2 != null;
  if (right_trigger.starred)
    assert right_trigger.spec != null && right_trigger.spec2 != null;

  // The guard on the right is checked by walking through the string backwards
  bit[u.l] right_okay;
  bit rightAccepting = 0;
  for (int j = u.l - 1; j >= 0; j--) {
    bit _r = 1; // is it okay @ j?
    if (right_trigger.starred) { // _g*g(#?)
      if (j == u.l - 1) {
	_r = 0;
	rightAccepting = matches_specification(u.s[u.l - 1], right_trigger.spec2);
      } else {
	_r = rightAccepting;
	rightAccepting =
	  (!right_trigger.endOfString && matches_specification(u.s[j], right_trigger.spec2))
	  || (rightAccepting && matches_specification(u.s[j], right_trigger.spec));
      }
    } else if (right_trigger.endOfString && right_trigger.spec == null) // _#
      _r = j == u.l - 1;
    else if (right_trigger.spec != null) { // _gg?#?
      _r = j < u.l - 1 && matches_specification(u.s[j + 1], right_trigger.spec);
      if (right_trigger.spec2 != null) // _gg
	_r = _r && j < u.l - 2 && matches_specification(u.s[j + 2], right_trigger.spec2);

      if (right_trigger.endOfString) {
	if (right_trigger.spec2 == null) { // _g#
	  _r = _r && (j == u.l - 2);
	} else { // _gg#
	  _r = _r && (j == u.l - 3);
	}
      }
    }
    right_okay[j] = _r;
  }
  
  // State machine for starred: either in accepting or rejecting state
  bit leftAccepting = 0;
  bit[u.l] left_okay;

  for (int j = 0; j < u.l; j++) {
    // Check to see if the left matches
    bit _left_okay = 1;
    if (left_trigger.starred) {
      if (j == 0) {
	_left_okay = 0;
	leftAccepting = matches_specification(u.s[0], left_trigger.spec2);
      } else {
	_left_okay = leftAccepting;
	leftAccepting =
	  (!left_trigger.endOfString && matches_specification(u.s[j], left_trigger.spec2))
	  || (leftAccepting && matches_specification(u.s[j], left_trigger.spec));
      }
    } else if (left_trigger.endOfString && left_trigger.spec == null) { // #_
      _left_okay = j == 0;
    } else if (left_trigger.spec != null) {
      _left_okay = j > 0 && matches_specification(u.s[j - 1], left_trigger.spec);
      if (left_trigger.spec2 != null) // (#?)gg_
	_left_okay = _left_okay && j > 1 && matches_specification(u.s[j - 2], left_trigger.spec2);

      if (left_trigger.endOfString) {
	if (left_trigger.spec2 == null) {
	  _left_okay = _left_okay && (j == 1);
	} else {
	  _left_okay = _left_okay && (j == 2);
	}
      }
    }
    left_okay[j] = _left_okay;
  }

  bit[u.l] middle_okay;
  for (int j = 0; j < u.l; j++) {
    middle_okay[j] = focus == null || matches_specification(u.s[j], focus);
  }

  bit[u.l] triggered = middle_okay&right_okay&left_okay;

  int output_length; // how long is the output
  // Deletion rule
  if (structural_change == null) {
    assert focus != null;
    
    int outputIndex = 0;
    for (int j = 0; j < u.l; j++) {
      if (!triggered[j]) {
	output[outputIndex] = u.s[j];
	outputIndex++;
      }
    }
    output_length = outputIndex;
  } else if (focus == null) { // insertion rule
    if (r.copyOffset == 0) // not copying
      assert constant_specification(structural_change);
    else // copying
      assert empty_specification(structural_change);

    // special case: / L_#
    if (right_trigger.endOfString && right_trigger.spec == null) {
      output[0::u.l] = u.s;
      output_length = u.l + left_okay[u.l - 1];
      output[u.l] =
	r.copyOffset == 0 ?
	extract_constant_sound(structural_change) :
	u.s[left_trigger.endOfString ?
	    (-1 - r.copyOffset) :
	    u.l + r.copyOffset];
    } else if (left_trigger.endOfString && left_trigger.spec == null) {
      // special case: / #_R
      output_length = u.l + right_okay[0];
      output[right_okay[0]::u.l]= u.s;
      if (right_okay[0]) {
	output[0] = r.copyOffset == 0 ?
	  extract_constant_sound(structural_change) :
	  u.s[right_trigger.endOfString ?
	      (u.l - r.copyOffset) :
	      (r.copyOffset - 1)];
      }
    } else assert 0;
    
  } else { // Modification rule
    for (int j = 0; j < u.l; j++) {
      output[j] = triggered[j] ?
	apply_specification(structural_change, u.s[j]) :
	u.s[j];
    }
    output_length = u.l;
  }
  
  return new Word(s = output[0::output_length], l = output_length);
}
