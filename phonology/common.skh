
#define MAXIMUMMORPHLENGTH 10
#define True 1
#define False 0

struct Sound {
  bit[NUMBEROFFEATURES] f;
}


struct Word {
  int l;
  Sound[l] s;
}

int word_length(Word w) { return w.l; }

bit sound_equal(Sound x, Sound y) {
  if (x == y) return 1;
  int f = 0;
  repeat (NUMBEROFFEATURES) {
      if (x.f[f] != y.f[f]) return 0;
      f++;
  }
  return 1;
}

bit word_equal(Word x, Word y) {
  if (x.l != y.l) return 0;
  for (int f = 0; f < x.l; f++) {
    if (!(sound_equal(x.s[f], y.s[f]))) return 0;
  }
  return 1;
}

Word concatenate3(Word a1,Word a2,Word a3) {
  Word a = new Word(l = a1.l + a2.l + a3.l, s = a1.s);
  a.s[a1.l :: a2.l] = a2.s;
  a.s[(a2.l + a1.l) :: a3.l] = a3.s;
  return a;
}

Word concatenate(Word a1,Word a2) {
  Word a = new Word(l = a1.l + a2.l,s = a1.s);
  a.s[a1.l :: a2.l] = a2.s;
  return a;
}

Word remove_sound(Word w,int j) {
  Word x = new Word(l = w.l - 1);
  for (int k = 0; k < j; k++)
    x.s[k] = w.s[k];
  for (int k = j + 1; k < w.l; k++)
    x.s[k-1] = w.s[k];
  return x;
}

Word make_word([int l],Sound[l] s) {
  Word w = new Word(l = l);
  w.s = s;
  return w;  
}

generator Word unknown_word() {
  int l = ??;
  assert l >= 0;
  
  Word w = new Word(l = l);
  int j = 0;
  repeat(MAXIMUMMORPHLENGTH) {
    if (j < l)
      w.s[j] = UNKNOWNSOUND;
    j++;
  }
  return w;
}

struct Specification{}
struct Vector extends Specification{
  bit[NUMBEROFFEATURES] mask;
  bit[NUMBEROFFEATURES] preference;
}
struct ConstantPhoneme extends Specification{
  Sound phoneme;
}




bit matches_specification(Sound sound, Specification specification) {
  switch (specification) {
  case Vector:{
    bit[NUMBEROFFEATURES] mistakeVector = (sound.f^(specification.preference))&specification.mask;
    int f = 0;
    repeat (NUMBEROFFEATURES) {
      if (mistakeVector[f]) return 0;
      f++;
    }
    return 1;
  }
  case ConstantPhoneme: {
    return sound_equal(sound, specification.phoneme);
  }
  }
}

Sound apply_specification(Specification specification, Sound sound) {
  switch (specification) {
  case Vector:{
    return new Sound(f = 
		     // New positives induced by the specification
		     (specification.mask & specification.preference) |
		     // Old features minus the ones that were removed by the specification
		     ((~specification.mask) & sound.f));
  }
  case ConstantPhoneme:{
    return specification.phoneme;
  }
  }
}

int specification_cost(Specification s) {
  if (s == null) return 0;
  switch(s) {
  case ConstantPhoneme:{ return 0; }
  case Vector:{
    int c = 3;
    for (int f = 0; f < NUMBEROFFEATURES; f++) {
      if (s.mask[f])
	c += s.preference[f] ? 1 : 2;
    }
    return c;
  }
  }
}

struct Guard {
  bit endOfString; // is it constrains to be at the end of string?
  Specification spec; // Primary specification - holds immediately adjacent
  //  Specification spec2; // Secondary specification - holds one apart from adjacent
}

struct Rule {
  Specification focus;
  Specification structural_change;
  Guard left_trigger;
  Guard right_trigger;
}

generator Guard unknown_guard() {
  Specification s = unknown_specification();
  return new Guard(endOfString = ??, spec = {| null | s |});
}
generator Specification unknown_specification() {
  return {| new Vector(mask = ??, preference = ??) | new ConstantPhoneme(phoneme = UNKNOWNSOUND) |};
}
  
generator Rule unknown_rule() {
  return new Rule(focus = unknown_specification(),
		  structural_change = unknown_specification(),
		  left_trigger = unknown_guard(),
		  right_trigger = unknown_guard());
}

int alternation_cost(Rule r) {
  return specification_cost(r.right_trigger.spec) + specification_cost(r.left_trigger.spec);
}

int rule_cost(Rule r) {
  return specification_cost(r.right_trigger.spec) + specification_cost(r.left_trigger.spec) +
    specification_cost(r.focus) + specification_cost(r.structural_change);
}


Word apply_rule(Rule r, Word u) {
  Specification focus = r.focus;
  Specification structural_change = r.structural_change;
  Guard left_trigger = r.left_trigger;
  Guard right_trigger = r.right_trigger;

  Word output = new Word(l = u.l);


  for (int j = 0; j < u.l; j++) {
    // Check to see if the left matches
    bit left_okay = 1;
    if (left_trigger.endOfString && left_trigger.spec == null) // #_
      left_okay = j == 0;
    else if (left_trigger.endOfString) // #g_
      assert 0;
    else if (left_trigger.spec != null)
      left_okay = j > 0 && matches_specification(u.s[j - 1], left_trigger.spec);

    // Check to see if the right matches
    bit right_okay = 1;
    if (right_trigger.endOfString && right_trigger.spec == null) // _#
      right_okay = j == u.l - 1;
    else if (right_trigger.endOfString) // _g#
      assert 0;
    else if (right_trigger.spec != null)
      right_okay = j < u.l - 1 && matches_specification(u.s[j + 1], right_trigger.spec);

    bit middle_okay =
      matches_specification(u.s[j], focus);
    
    output.s[j] = left_okay && right_okay && middle_okay ?
      apply_specification(structural_change, u.s[j]) :
      u.s[j];
  }
  
  return output;
}
