
#define MAXIMUMCOST 8
int validateCost(int c) { assert c < MAXIMUMCOST; return c; }

#define MAXIMUMMORPHLENGTH 15
#define True 1
#define False 0

struct Sound {
  bit[NUMBEROFFEATURES] f;
}


struct Word {
  int l;
  Sound[l] s;
}

int word_length(Word w) { return w.l; }

bit sound_equal(Sound x, Sound y) {
  if (x == y) return 1;
  int f = 0;
  repeat (NUMBEROFFEATURES) {
      if (x.f[f] != y.f[f]) return 0;
      f++;
  }
  return 1;
}

bit word_equal(Word x, Word y) {
  if (x.l != y.l) return 0;
  for (int f = 0; f < x.l; f++) {
    if (!(sound_equal(x.s[f], y.s[f]))) return 0;
  }
  return 1;
}

Word concatenate3(Word a1,Word a2,Word a3) {
  Word a = new Word(l = a1.l + a2.l + a3.l, s = a1.s);
  a.s[a1.l :: a2.l] = a2.s;
  a.s[(a2.l + a1.l) :: a3.l] = a3.s;
  return a;
}

Word concatenate(Word a1,Word a2) {
  Word a = new Word(l = a1.l + a2.l,s = a1.s);
  a.s[a1.l :: a2.l] = a2.s;
  return a;
}

Word remove_sound(Word w,int j) {
  Word x = new Word(l = w.l - 1);
  for (int k = 0; k < j; k++)
    x.s[k] = w.s[k];
  for (int k = j + 1; k < w.l; k++)
    x.s[k-1] = w.s[k];
  return x;
}

Word make_word([int l],Sound[l] s) {
  Word w = new Word(l = l);
  for (int j = 0; j < l; j++) {
    if (j < l) w.s[j] = s[j];
  }  
  return w;  
}

generator Word unknown_word() {
  int l = ??;
  assert l >= 0;
  
  Word w = new Word(l = l);
  int j = 0;
  repeat(MAXIMUMMORPHLENGTH) {
    if (j < l)
      w.s[j] = UNKNOWNSOUND;
    j++;
  }
  return w;
}

struct Specification{}
struct Vector extends Specification{
  bit[NUMBEROFFEATURES] mask;
  bit[NUMBEROFFEATURES] preference;
}
struct ConstantPhoneme extends Specification{
  Sound phoneme;
}




bit matches_specification(Sound sound, Specification specification) {
  switch (specification) {
  case Vector:{
    bit[NUMBEROFFEATURES] mistakeVector = (sound.f^(specification.preference))&specification.mask;
    int f = 0;
    repeat (NUMBEROFFEATURES) {
      if (mistakeVector[f]) return 0;
      f++;
    }
    return 1;
  }
  case ConstantPhoneme: {
    return sound_equal(sound, specification.phoneme);
  }
  }
}

Sound apply_specification(Specification specification, Sound sound) {
  switch (specification) {
  case Vector:{
    return new Sound(f = 
		     // New positives induced by the specification
		     (specification.mask & specification.preference) |
		     // Old features minus the ones that were removed by the specification
		     ((~specification.mask) & sound.f));
  }
  case ConstantPhoneme:{
    return specification.phoneme;
  }
  }
}

bit empty_vector(bit[NUMBEROFFEATURES] v) {
  int j = 0;
  repeat (NUMBEROFFEATURES){
    if (v[j]) return 0;
    j++;
  }
  return 1;
}

int specification_cost(Specification s) {
  if (s == null) return 0;
  switch(s) {
  case ConstantPhoneme:{ return 1; }
  case Vector:{
    assert !empty_vector(s.mask);
    int c = 0;
    int f = 0;
    repeat (NUMBEROFFEATURES) {
      // if (s.mask[f]) c += s.preference[f] ? 1 : 2;
      c = validateCost(c + s.mask[f]);
      f++;
    }
    return validateCost(c);
  }
  }
}

struct Guard {
  bit endOfString; // is it constrains to be at the end of string?
  bit starred; // is it of the form spec*spec2
  Specification spec; // Primary specification - holds immediately adjacent
  Specification spec2; // Secondary specification - holds one apart from adjacent
}

struct Rule {
  Specification focus;
  Specification structural_change;
  Guard left_trigger;
  Guard right_trigger;
}

generator Guard unknown_guard() {
  Specification s = unknown_specification();
  Specification s2 = unknown_specification();
  return new Guard(endOfString = ??, starred = ??, spec = {| null | s |}, spec2 = {| null | s2 |});
}
generator Specification unknown_specification() {
  return {| new Vector(mask = ??, preference = ??) | new ConstantPhoneme(phoneme = UNKNOWNSOUND) |};
}
  
generator Rule unknown_rule() {
  return new Rule(focus = unknown_specification(),
		  structural_change = unknown_specification(),
		  left_trigger = unknown_guard(),
		  right_trigger = unknown_guard());
}

int alternation_cost(Rule r) {
  return specification_cost(r.right_trigger.spec) + specification_cost(r.left_trigger.spec);
}

int guard_cost(Guard g) {
  return validateCost(specification_cost(g.spec) + specification_cost(g.spec2) + g.endOfString + g.starred);
}

int rule_cost(Rule r) {
  return validateCost(guard_cost(r.right_trigger) + guard_cost(r.left_trigger) +
		      specification_cost(r.focus) + specification_cost(r.structural_change));
}


Word apply_rule(Rule r, Word u) {
  Specification focus = r.focus;
  Specification structural_change = r.structural_change;
  Guard left_trigger = r.left_trigger;
  Guard right_trigger = r.right_trigger;

  // sanity check
  if (left_trigger.spec == null) assert left_trigger.spec2 == null;
  if (right_trigger.spec == null) assert right_trigger.spec2 == null;
  
  Word output = new Word(l = u.l);

  // * applies to the second spec
  if (left_trigger.starred)
    assert left_trigger.spec != null && left_trigger.spec2 != null && !left_trigger.endOfString;
  if (right_trigger.starred)
    assert right_trigger.spec != null && right_trigger.spec2 != null && !right_trigger.endOfString;

  // todo: right trigger starred
  assert !right_trigger.starred;
  assert !left_trigger.starred;

  //  if (left_trigger.spec != null)
  //    assert left_trigger.starred;

  // State machine for starred: either in accepting or rejecting state
  bit leftAccepting = 0;
  
  for (int j = 0; j < u.l; j++) {
    // Check to see if the left matches
    bit left_okay = 1;
    if (left_trigger.starred) {
      if (j == 0) {
	left_okay = 0;
	leftAccepting = matches_specification(u.s[0], left_trigger.spec2);
      } else {
	left_okay = leftAccepting;
	leftAccepting =
	  matches_specification(u.s[j], left_trigger.spec2) || (leftAccepting && matches_specification(u.s[j], left_trigger.spec));
      }
    } else if (left_trigger.endOfString && left_trigger.spec == null) // #_
      left_okay = j == 0;
    else if (left_trigger.endOfString) // #g_
      assert 0;
    else if (left_trigger.spec != null) {
      left_okay = j > 0 && matches_specification(u.s[j - 1], left_trigger.spec);
      if (left_trigger.spec2 != null) // gg_
	left_okay = left_okay && j > 1 && matches_specification(u.s[j - 2], left_trigger.spec2);
    }

    // Check to see if the right matches
    bit right_okay = 1;
    if (right_trigger.endOfString && right_trigger.spec == null) // _#
      right_okay = j == u.l - 1;
    else if (right_trigger.endOfString) // _g#
      assert 0;
    else if (right_trigger.spec != null) {
      right_okay = j < u.l - 1 && matches_specification(u.s[j + 1], right_trigger.spec);
      if (right_trigger.spec2 != null) // _gg
	right_okay = right_okay && j < u.l - 2 && matches_specification(u.s[j + 2], right_trigger.spec2);
    }

    bit middle_okay =
      matches_specification(u.s[j], focus);
    
    output.s[j] = left_okay && right_okay && middle_okay ?
      apply_specification(structural_change, u.s[j]) :
      u.s[j];
  }
  
  return output;
}
