// alternations basically already have their specifications given
// so it should be okay that they are a little bit bigger
#ifndef ALTERNATIONPROBLEM
#define MAXIMUMCOST 11
#else
#define MAXIMUMCOST 14
#endif
int validateCost(int c) { assert c < MAXIMUMCOST; return c; }

#define True 1
#define False 0

struct Sound {
  bit[NUMBEROFFEATURES] f;
}


struct Word {
  int l;
  Sound[l] s;
}

int word_length(Word w) { return w.l; }

bit sound_equal(Sound x, Sound y) {
  /* if (x == y) return 1; */
  /* int f = 0; */
  /* repeat (NUMBEROFFEATURES) { */
  /*     if (x.f[f] != y.f[f]) return 0; */
  /*     f++; */
  /* } */
  /* return 1; */
  return x == y;
}

bit word_equal(Word x, Word y) {
  if (x.l != y.l) return 0;
  for (int f = 0; f < x.l; f++) {
    if (!(sound_equal(x.s[f], y.s[f]))) return 0;
  }
  return 1;
}

Word concatenate3(Word a1,Word a2,Word a3) {
  if (a1.l == 0 && a3.l == 0) return a2;
  if (a1.l == 0) return concatenate(a2,a3);
  if (a3.l == 0) return concatenate(a1,a2);
  Word a = new Word(l = a1.l + a2.l + a3.l, s = a1.s);
  a.s[a1.l :: a2.l] = a2.s;
  a.s[(a2.l + a1.l) :: a3.l] = a3.s;
  return a;
}

Word concatenate(Word a1,Word a2) {
  Word a = new Word(l = a1.l + a2.l,s = a1.s);
  a.s[a1.l :: a2.l] = a2.s;
  return a;
}

Word make_word([int l],Sound[l] s) {
  Word w = new Word(l = l);
  for (int j = 0; j < l; j++) {
    if (j < l) w.s[j] = s[j];
  }  
  return w;  
}

generator Word unknown_word() {
  int l = ??;
  assert l >= 0 && l <= MAXIMUMMORPHLENGTH;
  
  Word w = new Word(l = l);
  int j = 0;
  repeat(MAXIMUMMORPHLENGTH) {
    if (j < l)
      w.s[j] = UNKNOWNSOUND;
    j++;
  }
  return w;
}

struct Specification{}
struct Vector extends Specification{
  bit[NUMBEROFFEATURES] mask;
  bit[NUMBEROFFEATURES] preference;
}
struct ConstantPhoneme extends Specification{
  Sound phoneme;
}

bit specification_equal(Specification p, Specification q) {
  if (p == null || q == null) return p == null && q == null;
  switch (p) {
  case Vector:{
    switch (q) {
    case Vector:{
      return p.mask == q.mask && (p.preference&p.mask) == (q.preference&q.mask);
    }
    case ConstantPhoneme:{ return 0; }
    }
  }
  case ConstantPhoneme:{
    switch (q) {
    case Vector:{ return 0; }
    case ConstantPhoneme:{ return p.phoneme == q.phoneme; }
    }
  }
  }
}

bit empty_specification(Specification p) {
  if (p == null) return 0;
  switch (p) {
  case Vector:{
    return empty_vector(p.mask);
  }
  case ConstantPhoneme:{ return 0; }
  }
}

bit constant_specification(Specification p) {
  if (p == null) return 0;
  switch (p) {
  case Vector:{return 0;
  }
  case ConstantPhoneme:{ return 1; }
  }
}

Sound extract_constant_sound(Specification p) {
  if (p == null) return null;
  switch (p) {
  case Vector:{return null;}
  case ConstantPhoneme:{ return p.phoneme; }
  }
}

bit matches_specification(Sound sound, Specification specification) {
  switch (specification) {
  case Vector:{
    bit[NUMBEROFFEATURES] mistakeVector = (sound.f^(specification.preference))&specification.mask;
    int f = 0;
    repeat (NUMBEROFFEATURES) {
      if (mistakeVector[f]) return 0;
      f++;
    }
    return 1;
  }
  case ConstantPhoneme: {
    return sound_equal(sound, specification.phoneme);
  }
  }
}


Sound apply_specification(Specification specification, Sound sound) {
  switch (specification) {
  case Vector:{
    return features2sound(
			  // New positives induced by the specification
			  (specification.mask & specification.preference) |
			  // Old features minus the ones that were removed by the specification
			  ((~specification.mask) & sound.f & (~ZEROFEATURES(specification.mask))));
  }
  case ConstantPhoneme:{
    return specification.phoneme;
  }
  }
}

bit empty_vector(bit[NUMBEROFFEATURES] v) {
  int j = 0;
  repeat (NUMBEROFFEATURES){
    if (v[j]) return 0;
    j++;
  }
  return 1;
}

#ifdef SYLLABLEBOUNDARYFEATURE
int syllable_starting_at([int l],Sound[l] u, int e) {
  if (e < 0 || e >= l) return -1;
  // returns a negative number if there is no syllable starting at e
  // returns the index of the end of the syllable otherwise
  if (e == 0 || u[e - 1] == SYLLABLEBOUNDARYPHONEME) { // before the beginning of the syllable should be the end of another syllable
    for (int d = 1; d < 4; d++) {
      int test_index = e + d;
      if (test_index == l) return -1;
      if (u[test_index] == SYLLABLEBOUNDARYPHONEME)
	return test_index;
    }
  }
  return -1;
}
bit is_syllable_starting_at([int l],Sound[l] u,int e){ return syllable_starting_at(u,e) != -1; }
bit are_two_syllables_starting_at([int l],Sound[l] u,int e){
  e = syllable_starting_at(u,e);
  if (e == -1) return 0;
  return syllable_starting_at(u,e + 1) != -1;
}
int syllable_ending_at([int l],Sound[l] u, int e) {
  if (e < 0 || e >= l) return -1;
  // returns a negative number if there is no syllable ending at e
  // returns the index of the start of the syllable otherwise
  if (u[e] == SYLLABLEBOUNDARYPHONEME) {
    for (int d = 1; d < 4; d++) {
      int test_index = e - d;
      if (test_index == 0) return 0; // butting up against the start of the word
      if (u[test_index] == SYLLABLEBOUNDARYPHONEME) // butting up against the previous syllable
	return test_index + 1;
    }
  }
  return -1;
}
bit is_syllable_ending_at([int l],Sound[l] u,int e) { return syllable_ending_at(u,e) == -1; }
bit are_two_syllables_ending_at([int l],Sound[l] u,int e){
  e = syllable_ending_at(u,e);
  if (e != -1) return 0;
  return syllable_ending_at(u,e - 1) != -1;
}
bit is_syllable_specification(Specification s) {
  if (s == null) { return 0; }
  switch(s){
  case Vector:{ return 0; }
  case ConstantPhoneme:{ return s.phoneme == SYLLABLEBOUNDARYPHONEME;}
  }
}
bit has_syllable_feature(Specification s) {
  if (s == null) { return 0; }
  switch(s){
  case Vector:{
    return s.mask[SYLLABLEBOUNDARYFEATURE];
  }
  case ConstantPhoneme:{ return 0;}
  }
}
#endif

int specification_cost(Specification s) {
  if (s == null) return 2;
  switch(s) {
  case ConstantPhoneme:{ return 2; }
  case Vector:{
    int c = 1;
    int f = 0;
    repeat (NUMBEROFFEATURES) {
      c = validateCost(c + s.mask[f]);
      f++;
    }
    // Alternation problems basically have their specification already given
    // So don't limit it
#ifndef ALTERNATIONPROBLEM    
    assert c < 5; // at most 3 features mentioned
#endif
    return c;
  }
  }
}


int guard_specification_cost(Specification s) {
  if (s == null) return 0;
  switch(s) {
  case ConstantPhoneme:{ return 2; }
  case Vector:{
    //    if (empty_vector(s.mask)) return 1;
    //    assert !empty_vector(s.mask);
    int c = 1;
    int f = 0;
    repeat (NUMBEROFFEATURES) {
      c = validateCost(c + s.mask[f]);
      f++;
    }
    assert c < 5; // at most 3 features mentioned
    return c;
  }
  }
}

struct Guard {
  bit endOfString; // is it constrains to be at the end of string?
  bit starred; // is it of the form spec*spec2
  Specification spec; // Primary specification - holds immediately adjacent
  Specification spec2; // Secondary specification - holds one apart from adjacent
}

bit guard_equal(Guard p, Guard q) {
  return p.endOfString == q.endOfString &&
    p.starred == q.starred &&
    specification_equal(p.spec, q.spec) &&
    specification_equal(p.spec2, q.spec2);
}

struct Rule {
  Specification focus;
  Specification structural_change;
  Guard left_trigger;
  Guard right_trigger;
  // If we are inserting a new phoneme, copy it from this offset:
  // 0 = do not copy; -(1|2) = copy from left; +(1|2) = copy from right
  int copyOffset;
}


/* it's possible for structural changes to be redundant or make no sense
for example : [+hi  +low] or [-middle] 
this forces them into a canonical form. */

bit is_valid_structural_change(Specification s) {
  if (s == null) return 1;
  switch (s){
  case ConstantPhoneme:{}
  case Vector:{
    // mutually exclude high middle and low
    MUTUALLYEXCLUDE(s)
      ;
      }
  }
  return 1;
}

bit is_deletion_rule(Rule r) { return r.structural_change == null; }
bit is_insertion_rule(Rule r) { return r.focus == null; }

bit rule_equal(Rule p, Rule q) {
  return specification_equal(p.focus, q.focus) &&
    specification_equal(p.structural_change, q.structural_change) &&
    guard_equal(p.left_trigger, q.left_trigger) &&
    guard_equal(p.right_trigger, q.right_trigger) &&
    p.copyOffset == q.copyOffset;
}

bit alternation_equal(Rule p, Rule q) {
  return guard_equal(p.left_trigger, q.left_trigger) &&
    guard_equal(p.right_trigger, q.right_trigger);
}

generator Guard unknown_guard() {
  Specification s = unknown_specification();
  Specification s2 = unknown_specification();
  return new Guard(endOfString = ??, starred = ??, spec = {| null | s |}, spec2 = {| null | s2 |});
}
generator Specification unknown_specification() {
  return {| new Vector(mask = ??, preference = ??) | new ConstantPhoneme(phoneme = UNKNOWNSOUND) |};
}
  
generator Rule unknown_rule() {
  return new Rule(focus = {| null | unknown_specification() |},
		  structural_change = {| null | unknown_specification() |},
		  left_trigger = unknown_guard(),
		  right_trigger = unknown_guard(),
		  copyOffset = {| 0 | 1 | -1 | -2 | 2 |});
}

int alternation_cost(Rule r) {
  // For alternations the focus and structural change don't matter because they are essentially given by the problem
  return guard_cost(r.right_trigger) + guard_cost(r.left_trigger);
}

int guard_cost(Guard g) {
  return validateCost(guard_specification_cost(g.spec) +
		      guard_specification_cost(g.spec2) +
		      g.endOfString +
		      g.starred);
}

bit guard_does_something(Guard g){
  return g.endOfString || g.spec != null;
}

// apply_guard(u, g, 0)[j] = .*g matches u[0],u[1],...,u[j-1]. eg, the first j elements of u.
// apply_guard(u, g, 1)[j] = g.* matches u[j],u[j+1],...,u[l-1], eg, from j onward
bit[l+1] apply_guard([int l], Sound[l] u, Guard g, bit R, int unrollBound){
  // guard sanity checks
  if (g.spec == null) assert g.spec2 == null;
  if (g.starred) { // * applies to the second specification
    assert g.spec != null && g.spec2 != null;
    // do not put a star on constant
    assert !constant_specification(g.spec);
#ifdef SYLLABLEBOUNDARYFEATURE
    // todo: allow star on and with syllable
    assert !is_syllable_specification(g.spec);
    assert !is_syllable_specification(g.spec2);
#endif
  }
#ifdef SYLLABLEBOUNDARYFEATURE
  if (is_syllable_specification(g.spec2))
    assert is_syllable_specification(g.spec);
#endif


  // The index counts how many sounds we have consumed from the input
  // consider making these macros if it ends up being too slow
  // not sure if that even matters
/* #define index2okay(i) (R? (l - (i)) : i) */
/* #define index2sound(o) (R? (l - 1 - o) : o) */
  int index2okay(int i){
    if (R) return l - i;
    else return i;
  }
  int index2sound(int o){
    if (R) return l - 1 - (o - 1);
    else return (o - 1);
  }

  bit[l + 1] okay;
  // the only way that the empty string can be matched by .*g is if g is either empty or #
  // # by itself entails that both of the specifications are null
  okay[index2okay(0)] = (g.spec == null && g.spec2 == null);

  // State machine for starred: either in accepting or rejecting state
  bit accepting = 0;
  for (int j = 1; j <= l; j++) {
    assert j <= unrollBound;
    
    // j counts how many sounds we have consumed from the input
    Sound this_sound = u[index2sound(j)]; // R sounds: (l-1), (l-2), ..., 0
    bit this_is_okay = 1;
    if (g.starred) { // (#?)gg*
      bit stay_in_accepting_state = accepting && matches_specification(this_sound, g.spec);
      if (!g.endOfString) { // gg*_
	accepting = matches_specification(this_sound, g.spec2) || stay_in_accepting_state;
      } else { // #gg*_
	accepting = matches_specification(u[index2sound(1)], g.spec2) &&
	  (j == 1 || stay_in_accepting_state);
      }
      this_is_okay = accepting;
    } else if (g.endOfString && g.spec == null) { // #_
      this_is_okay = 0;
    } else { // #?g?g?
      this_is_okay = this_is_okay && (g.spec == null || (
#ifdef SYLLABLEBOUNDARYFEATURE
				      is_syllable_specification(g.spec)?
				      (R? is_syllable_starting_at(u,index2sound(j)) : is_syllable_ending_at(u,index2sound(j))) :
#endif
				      matches_specification(this_sound, g.spec)));

      // This is the index of whatever we were looking at in the previous loop iteration
      int secondary_index = index2sound(j - 1); //R? (l + 1 - j):(j - 2);
      this_is_okay = this_is_okay && (g.spec2 == null || (
#ifdef SYLLABLEBOUNDARYFEATURE
				      is_syllable_specification(g.spec2)?
				      (R? are_two_syllables_starting_at(u,index2sound(j))
				       : are_two_syllables_ending_at(u,index2sound(j))) :
#endif
				      (j > 1 && matches_specification(u[secondary_index], g.spec2))));

      if (g.endOfString) { // is this off by one???
	// #g _
	if (g.spec2 == null) this_is_okay = this_is_okay && (
#ifdef SYLLABLEBOUNDARYFEATURE
			       is_syllable_specification(g.spec)?
			       (R? syllable_starting_at(u,index2sound(j)) == l - 1
				: syllable_ending_at(u,index2sound(j)) == 0) :
#endif
			       j == 1);

	// #gg _
	else                 this_is_okay = this_is_okay && (
#ifdef SYLLABLEBOUNDARYFEATURE
			       is_syllable_specification(g.spec2)?
			       (R? syllable_starting_at(u,syllable_starting_at(u,index2sound(j))+1) == l - 1
				: syllable_ending_at(u,syllable_ending_at(u,index2sound(j))-1) == 0) :
#endif
			       j == 2);
      }
    }

    okay[index2okay(j)] = this_is_okay;
  }

  return okay;
}

int rule_cost(Rule r) {
  return validateCost(guard_cost(r.right_trigger) + guard_cost(r.left_trigger) +
		      specification_cost(r.focus) + specification_cost(r.structural_change));
}

Word apply_rule(Rule r, Word u, int unrollBound) {
  Specification focus = r.focus;
  Specification structural_change = r.structural_change;
  Guard left_trigger = r.left_trigger;
  Guard right_trigger = r.right_trigger;

  // sanity check
  if (focus != null) assert r.copyOffset == 0; // not inserting so don't copy
  if (r.copyOffset != 0) assert empty_specification(structural_change);
  // HEURISTIC: long-distance dependencies tend to only occur on one side
  if (left_trigger.starred) assert !right_trigger.starred;
  if (right_trigger.starred) assert !left_trigger.starred;
  // K > [features] is always equivalent to K > K at a cost which is no greater
  if (constant_specification(focus)) assert constant_specification(structural_change) || structural_change == null;
  // K > K / _ is always over fitting
  if (constant_specification(focus) && constant_specification(structural_change))
    assert guard_does_something(left_trigger) || guard_does_something(right_trigger);
  
  assert is_valid_structural_change(structural_change);
#ifdef SYLLABLEBOUNDARYFEATURE
  // Syllables are encoded only as the special syllable phoneme
  assert !has_syllable_feature(left_trigger.spec);
  assert !has_syllable_feature(left_trigger.spec2);
  assert !has_syllable_feature(right_trigger.spec);
  assert !has_syllable_feature(right_trigger.spec2);
  assert !has_syllable_feature(focus);
  assert !has_syllable_feature(structural_change);
#endif
#ifndef SYLLABLEBOUNDARYFEATURE
  assert r.copyOffset == 0;
#define MAXIMALINCREASE 1
#else
#define MAXIMALINCREASE 4
#endif


  
  Sound[u.l + MAXIMALINCREASE] output;

  bit[u.l + 1] right_okay = apply_guard(u.s,right_trigger,1, unrollBound);
  bit right_final_okay = right_okay[0];
  
  bit[u.l + 1] left_okay = apply_guard(u.s,left_trigger,0, unrollBound);
  bit left_final_okay = left_okay[u.l];


  bit[u.l] middle_okay;
  for (int j = 0; j < u.l; j++) {
    middle_okay[j] = focus == null || matches_specification(u.s[j], focus);
    assert j < unrollBound;
  }

  bit[u.l] triggered;
  for (int j = 0; j < u.l; j++) {
    triggered[j] = middle_okay[j] && right_okay[j + 1] && left_okay[j];
    assert j < unrollBound;
  }

  int output_length; // how long is the output
  // Deletion rule
  if (structural_change == null) {
    assert focus != null;

    // special case: rule doesn't apply
    bit ruleApplies = 0;
    for (int j = 0; j < u.l; j++){
      assert j < unrollBound;
      if (triggered[j]) {
	assert !ruleApplies;
	ruleApplies = 1;
      }
    }
    if (!ruleApplies) return u;
    
    int outputIndex = 0;
    for (int j = 0; j < u.l; j++) {
      assert j < unrollBound;
      if (!triggered[j]) {
	output[outputIndex] = u.s[j];
	outputIndex++;
      }
    }
    output_length = u.l - 1;
  } else if (focus == null) { // insertion rule
    if (r.copyOffset == 0) { // not copying
      assert constant_specification(structural_change);
    } else { // copying
      assert empty_specification(structural_change);
      if (r.copyOffset == 1) assert right_trigger.spec != null;
      if (r.copyOffset == 2) assert right_trigger.spec2 != null;
      if (r.copyOffset == -1) assert left_trigger.spec != null;
      if (r.copyOffset == -2) assert left_trigger.spec2 != null;
    }

#ifdef SYLLABLEBOUNDARYFEATURE
    bit inserting_syllable = (r.copyOffset == 1 && is_syllable_specification(right_trigger.spec)) ||
      (r.copyOffset == 2 && is_syllable_specification(right_trigger.spec2)) ||
      (r.copyOffset == -1 && is_syllable_specification(left_trigger.spec)) ||
      (r.copyOffset == -2 && is_syllable_specification(left_trigger.spec2));
    int inserted = 0;
#else    
    bit inserted = 0;
#endif
    
    // Should we insert before u[j]?
    for (int j = 0; j <= u.l; j++) {
      assert j < unrollBound;
      if (left_okay[j] && right_okay[j]) {
	assert inserted == 0;
#ifdef SYLLABLEBOUNDARYFEATURE
	if (inserting_syllable) {
	  int starting, ending; // we will copy the syllable which begins at index starting and ends at index ending. Includes the content at ending.
	  if (r.copyOffset > 0) { // grab a syllable to the right
	    starting = j;
	    ending = syllable_starting_at(u.s,j);
	    if (r.copyOffset == 2) {
	      starting = ending + 1;
	      ending = syllable_starting_at(u.s,starting);
	    }
	  } else { // grab a syllable to the left
	    starting = syllable_ending_at(u.s,j - 1);
	    ending = j - 1;
	    if (r.copyOffset == -2) {
	      ending = starting - 1;
	      starting = syllable_ending_at(u.s,ending);
	    }
	  }
	  // copy the syllable from starting to ending
	  for (int k = starting; k <= ending; k++) {
	    output[j + inserted] = u.s[k];
	    inserted++;
	  }
	} else { // not inserting a syllable so just use the old logic
#endif
	inserted = 1; 
	output[j] = r.copyOffset == 0?
	  extract_constant_sound(structural_change) : (u.s[j + r.copyOffset - (r.copyOffset > 0 ? 1 : 0)]);
#ifdef SYLLABLEBOUNDARYFEATURE
	}
#endif
      }
      if (j < u.l) 
	output[j + inserted] = u.s[j];
    }
    if (inserted == 0) return u;
    output_length = u.l + inserted;
  } else { // Modification rule
    for (int j = 0; j < u.l; j++) {
      assert j < unrollBound;
      output[j] = triggered[j] ?
	apply_specification(structural_change, u.s[j]) :
	u.s[j];
    }
    output_length = u.l;
  }
  
  return new Word(s = output[0::output_length], l = output_length);
}
